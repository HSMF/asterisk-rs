// this is file generated by asterisk-rs 0.1.0
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::let_unit_value)]
#![allow(unused_variables)]

use super::ast::*;
use super::lex::Token;

#[derive(Debug, Clone)]
pub enum Error {
    Msg(String),
    UnexpectedToken {
        expected: Vec<Option<Token>>,
        received: Option<Token>,
        state_id: usize,
        remaining_input: Vec<Token>,
    },
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self:?}")
    }
}

impl std::error::Error for Error {}

impl Error {
    fn msg(m: &str) -> Self {
        Error::Msg(m.to_owned())
    }
}

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, Clone, Copy)]
enum State {
    State1,
    State2,
    State3,
    State4,
    State5,
    State6,
    State7,
    State8,
    State9,
    State10,
    State11,
    State12,
    State13,
    State14,
    State15,
    State16,
    State17,
    State18,
    State19,
    State20,
    State21,
    State22,
    State23,
    State24,
}

#[allow(dead_code)]
enum StackValue {
    NonTerm_Configs(Vec<(String, String)>),
    NonTerm_Rules(Vec<Rule>),
    NonTerm_Config((String, String)),
    NonTerm_Rule(Rule),
    NonTerm_CaseList(Vec<Expansion>),
    NonTerm_Case(Expansion),
    NonTerm_Idents(Vec<String>),
    NonTerm_Grammar(Spec),
    NonTerm_S0(Spec),
    Term_Ident(String),
    Term_Literal(String),
    None,
}

enum NonTerm {
    Configs,
    Rules,
    Config,
    Rule,
    CaseList,
    Case,
    Idents,
    Grammar,
    S0,
}

enum TokenType {
    Term(Token),
    NonTerm(NonTerm),
    TermEof,
}

struct Stack(Vec<(State, TokenType, StackValue)>);

impl Stack {
    fn pop(&mut self) -> Result<(State, TokenType, StackValue)> {
        match self.0.pop() {
            None => Err(Error::msg("stack was empty. this is probably a bug")),
            Some(x) => Ok(x),
        }
    }

    fn push(&mut self, state: State, typ: TokenType, val: StackValue) {
        self.0.push((state, typ, val));
    }

    fn peek(&self) -> Result<&(State, TokenType, StackValue)> {
        match self.0.last() {
            None => Err(Error::msg("stack was empty. this is probably a bug")),
            Some(x) => Ok(x),
        }
    }
}

pub fn parse<I>(tokens: I) -> Result<Spec>
where
    I: Iterator<Item = Token>,
{
    let mut tokens = tokens.peekable();
    let mut state = State::State1;
    let mut stack = Stack(Vec::new());
    stack.push(
        State::State1,
        TokenType::NonTerm(NonTerm::S0),
        StackValue::None,
    );
    fn goto_Configs(state: State) -> Result<State> {
        match state {
            State::State1 => Ok(State::State20),
            _ => Err(Error::msg(
                "failed to match in Configs. this is probably a bug",
            )),
        }
    }
    fn goto_Rules(state: State) -> Result<State> {
        match state {
            State::State1 => Ok(State::State15),
            State::State17 => Ok(State::State18),
            State::State20 => Ok(State::State22),
            _ => Err(Error::msg(
                "failed to match in Rules. this is probably a bug",
            )),
        }
    }
    fn goto_Config(state: State) -> Result<State> {
        match state {
            State::State1 => Ok(State::State16),
            State::State20 => Ok(State::State21),
            _ => Err(Error::msg(
                "failed to match in Config. this is probably a bug",
            )),
        }
    }
    fn goto_Rule(state: State) -> Result<State> {
        match state {
            State::State1 => Ok(State::State17),
            State::State17 => Ok(State::State17),
            State::State20 => Ok(State::State17),
            _ => Err(Error::msg(
                "failed to match in Rule. this is probably a bug",
            )),
        }
    }
    fn goto_CaseList(state: State) -> Result<State> {
        match state {
            State::State7 => Ok(State::State14),
            State::State8 => Ok(State::State13),
            _ => Err(Error::msg(
                "failed to match in CaseList. this is probably a bug",
            )),
        }
    }
    fn goto_Case(state: State) -> Result<State> {
        match state {
            State::State7 => Ok(State::State8),
            State::State8 => Ok(State::State8),
            _ => Err(Error::msg(
                "failed to match in Case. this is probably a bug",
            )),
        }
    }
    fn goto_Idents(state: State) -> Result<State> {
        match state {
            State::State9 => Ok(State::State10),
            _ => Err(Error::msg(
                "failed to match in Idents. this is probably a bug",
            )),
        }
    }
    fn goto_Grammar(state: State) -> Result<State> {
        match state {
            State::State1 => Ok(State::State23),
            _ => Err(Error::msg(
                "failed to match in Grammar. this is probably a bug",
            )),
        }
    }

    loop {
        match state {
            State::State1 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let head = tokens.next().unwrap();
                    let Token::Ident(value) = head else {
                        unreachable!()
                    };
                    let head = Token::Ident(Default::default());
                    state = State::State2;
                    stack.push(state, TokenType::Term(head), StackValue::Term_Ident(value));
                }
                None => {
                    let value = { Vec::new() };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Rules(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Rules),
                        StackValue::NonTerm_Rules(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![Some(Token::Ident(Default::default())), None],
                        received: tokens.next(),
                        state_id: 1,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State2 => match tokens.peek() {
                Some(Token::Equals) => {
                    let head = tokens.next().unwrap();
                    state = State::State3;
                    stack.push(state, TokenType::Term(head), StackValue::None);
                }
                Some(Token::Colon) => {
                    let head = tokens.next().unwrap();
                    state = State::State6;
                    stack.push(state, TokenType::Term(head), StackValue::None);
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![Some(Token::Equals), Some(Token::Colon)],
                        received: tokens.next(),
                        state_id: 2,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State3 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let head = tokens.next().unwrap();
                    let Token::Ident(value) = head else {
                        unreachable!()
                    };
                    let head = Token::Ident(Default::default());
                    state = State::State5;
                    stack.push(state, TokenType::Term(head), StackValue::Term_Ident(value));
                }
                Some(Token::Literal(_)) => {
                    let head = tokens.next().unwrap();
                    let Token::Literal(value) = head else {
                        unreachable!()
                    };
                    let head = Token::Literal(Default::default());
                    state = State::State4;
                    stack.push(
                        state,
                        TokenType::Term(head),
                        StackValue::Term_Literal(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![
                            Some(Token::Ident(Default::default())),
                            Some(Token::Literal(Default::default())),
                        ],
                        received: tokens.next(),
                        state_id: 3,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State4 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let v2 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::Term(Token::Literal(_)),
                                StackValue::Term_Literal(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Literal` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v1 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Equals), StackValue::None) => (),
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Equals` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let value = { (v0, v2) };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Config(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Config),
                        StackValue::NonTerm_Config(value),
                    );
                }
                None => {
                    let v2 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::Term(Token::Literal(_)),
                                StackValue::Term_Literal(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Literal` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v1 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Equals), StackValue::None) => (),
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Equals` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let value = { (v0, v2) };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Config(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Config),
                        StackValue::NonTerm_Config(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![Some(Token::Ident(Default::default())), None],
                        received: tokens.next(),
                        state_id: 4,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State5 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let v2 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let v1 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Equals), StackValue::None) => (),
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Equals` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let value = { (v0, v2) };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Config(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Config),
                        StackValue::NonTerm_Config(value),
                    );
                }
                None => {
                    let v2 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let v1 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Equals), StackValue::None) => (),
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Equals` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let value = { (v0, v2) };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Config(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Config),
                        StackValue::NonTerm_Config(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![Some(Token::Ident(Default::default())), None],
                        received: tokens.next(),
                        state_id: 5,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State6 => match tokens.peek() {
                Some(Token::Literal(_)) => {
                    let head = tokens.next().unwrap();
                    let Token::Literal(value) = head else {
                        unreachable!()
                    };
                    let head = Token::Literal(Default::default());
                    state = State::State7;
                    stack.push(
                        state,
                        TokenType::Term(head),
                        StackValue::Term_Literal(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![Some(Token::Literal(Default::default()))],
                        received: tokens.next(),
                        state_id: 6,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State7 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let value = { Vec::new() };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_CaseList(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::CaseList),
                        StackValue::NonTerm_CaseList(value),
                    );
                }
                Some(Token::Pipe) => {
                    let head = tokens.next().unwrap();
                    state = State::State9;
                    stack.push(state, TokenType::Term(head), StackValue::None);
                }
                None => {
                    let value = { Vec::new() };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_CaseList(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::CaseList),
                        StackValue::NonTerm_CaseList(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![
                            None,
                            Some(Token::Ident(Default::default())),
                            Some(Token::Pipe),
                        ],
                        received: tokens.next(),
                        state_id: 7,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State8 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let value = { Vec::new() };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_CaseList(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::CaseList),
                        StackValue::NonTerm_CaseList(value),
                    );
                }
                Some(Token::Pipe) => {
                    let head = tokens.next().unwrap();
                    state = State::State9;
                    stack.push(state, TokenType::Term(head), StackValue::None);
                }
                None => {
                    let value = { Vec::new() };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_CaseList(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::CaseList),
                        StackValue::NonTerm_CaseList(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![
                            Some(Token::Ident(Default::default())),
                            Some(Token::Pipe),
                            None,
                        ],
                        received: tokens.next(),
                        state_id: 8,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State9 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let value = { Vec::new() };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Idents(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Idents),
                        StackValue::NonTerm_Idents(value),
                    );
                }
                Some(Token::Literal(_)) => {
                    let value = { Vec::new() };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Idents(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Idents),
                        StackValue::NonTerm_Idents(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![
                            Some(Token::Literal(Default::default())),
                            Some(Token::Ident(Default::default())),
                        ],
                        received: tokens.next(),
                        state_id: 9,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State10 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let head = tokens.next().unwrap();
                    let Token::Ident(value) = head else {
                        unreachable!()
                    };
                    let head = Token::Ident(Default::default());
                    state = State::State12;
                    stack.push(state, TokenType::Term(head), StackValue::Term_Ident(value));
                }
                Some(Token::Literal(_)) => {
                    let head = tokens.next().unwrap();
                    let Token::Literal(value) = head else {
                        unreachable!()
                    };
                    let head = Token::Literal(Default::default());
                    state = State::State11;
                    stack.push(
                        state,
                        TokenType::Term(head),
                        StackValue::Term_Literal(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![
                            Some(Token::Ident(Default::default())),
                            Some(Token::Literal(Default::default())),
                        ],
                        received: tokens.next(),
                        state_id: 10,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State11 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let v2 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::Term(Token::Literal(_)),
                                StackValue::Term_Literal(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Literal` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v1 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Idents),
                                StackValue::NonTerm_Idents(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Idents to be on the stack"))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Pipe), StackValue::None) => (),
                            _ => {
                                return Err(Error::msg("expected token `Pipe` to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        Expansion {
                            tokens: v1,
                            code: v2,
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Case(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Case),
                        StackValue::NonTerm_Case(value),
                    );
                }
                Some(Token::Pipe) => {
                    let v2 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::Term(Token::Literal(_)),
                                StackValue::Term_Literal(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Literal` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v1 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Idents),
                                StackValue::NonTerm_Idents(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Idents to be on the stack"))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Pipe), StackValue::None) => (),
                            _ => {
                                return Err(Error::msg("expected token `Pipe` to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        Expansion {
                            tokens: v1,
                            code: v2,
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Case(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Case),
                        StackValue::NonTerm_Case(value),
                    );
                }
                None => {
                    let v2 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::Term(Token::Literal(_)),
                                StackValue::Term_Literal(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Literal` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v1 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Idents),
                                StackValue::NonTerm_Idents(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Idents to be on the stack"))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Pipe), StackValue::None) => (),
                            _ => {
                                return Err(Error::msg("expected token `Pipe` to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        Expansion {
                            tokens: v1,
                            code: v2,
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Case(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Case),
                        StackValue::NonTerm_Case(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![
                            Some(Token::Pipe),
                            None,
                            Some(Token::Ident(Default::default())),
                        ],
                        received: tokens.next(),
                        state_id: 11,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State12 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let v1 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Idents),
                                StackValue::NonTerm_Idents(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Idents to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        {
                            let mut v = v0;
                            v.push(v1);
                            v
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Idents(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Idents),
                        StackValue::NonTerm_Idents(value),
                    );
                }
                Some(Token::Literal(_)) => {
                    let v1 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Idents),
                                StackValue::NonTerm_Idents(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Idents to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        {
                            let mut v = v0;
                            v.push(v1);
                            v
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Idents(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Idents),
                        StackValue::NonTerm_Idents(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![
                            Some(Token::Ident(Default::default())),
                            Some(Token::Literal(Default::default())),
                        ],
                        received: tokens.next(),
                        state_id: 12,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State13 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let v1 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::CaseList),
                                StackValue::NonTerm_CaseList(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token CaseList to be on the stack",
                                ))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::NonTerm(NonTerm::Case), StackValue::NonTerm_Case(v)) => {
                                v
                            }
                            _ => return Err(Error::msg("expected token Case to be on the stack")),
                        }
                    };
                    let value = {
                        {
                            let mut v = v1;
                            v.push(v0);
                            v
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_CaseList(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::CaseList),
                        StackValue::NonTerm_CaseList(value),
                    );
                }
                None => {
                    let v1 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::CaseList),
                                StackValue::NonTerm_CaseList(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token CaseList to be on the stack",
                                ))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::NonTerm(NonTerm::Case), StackValue::NonTerm_Case(v)) => {
                                v
                            }
                            _ => return Err(Error::msg("expected token Case to be on the stack")),
                        }
                    };
                    let value = {
                        {
                            let mut v = v1;
                            v.push(v0);
                            v
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_CaseList(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::CaseList),
                        StackValue::NonTerm_CaseList(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![None, Some(Token::Ident(Default::default()))],
                        received: tokens.next(),
                        state_id: 13,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State14 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let v3 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::CaseList),
                                StackValue::NonTerm_CaseList(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token CaseList to be on the stack",
                                ))
                            }
                        }
                    };
                    let v2 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::Term(Token::Literal(_)),
                                StackValue::Term_Literal(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Literal` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v1 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Colon), StackValue::None) => (),
                            _ => {
                                return Err(Error::msg("expected token `Colon` to be on the stack"))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        Rule {
                            name: v0,
                            typ: v2,
                            expansions: v3,
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Rule(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Rule),
                        StackValue::NonTerm_Rule(value),
                    );
                }
                None => {
                    let v3 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::CaseList),
                                StackValue::NonTerm_CaseList(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token CaseList to be on the stack",
                                ))
                            }
                        }
                    };
                    let v2 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::Term(Token::Literal(_)),
                                StackValue::Term_Literal(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg(
                                    "expected token `Literal` to be on the stack",
                                ))
                            }
                        }
                    };
                    let v1 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Colon), StackValue::None) => (),
                            _ => {
                                return Err(Error::msg("expected token `Colon` to be on the stack"))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::Term(Token::Ident(_)), StackValue::Term_Ident(v)) => v,
                            _ => {
                                return Err(Error::msg("expected token `Ident` to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        Rule {
                            name: v0,
                            typ: v2,
                            expansions: v3,
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Rule(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Rule),
                        StackValue::NonTerm_Rule(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![None, Some(Token::Ident(Default::default()))],
                        received: tokens.next(),
                        state_id: 14,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State15 => match tokens.peek() {
                None => {
                    let v0 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Rules),
                                StackValue::NonTerm_Rules(v),
                            ) => v,
                            _ => return Err(Error::msg("expected token Rules to be on the stack")),
                        }
                    };
                    let value = {
                        Spec {
                            rules: v0,
                            configs: Vec::new(),
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Grammar(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Grammar),
                        StackValue::NonTerm_Grammar(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![None],
                        received: tokens.next(),
                        state_id: 15,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State16 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let v0 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Config),
                                StackValue::NonTerm_Config(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Config to be on the stack"))
                            }
                        }
                    };
                    let value = { vec![v0] };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Configs(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Configs),
                        StackValue::NonTerm_Configs(value),
                    );
                }
                None => {
                    let v0 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Config),
                                StackValue::NonTerm_Config(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Config to be on the stack"))
                            }
                        }
                    };
                    let value = { vec![v0] };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Configs(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Configs),
                        StackValue::NonTerm_Configs(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![None, Some(Token::Ident(Default::default()))],
                        received: tokens.next(),
                        state_id: 16,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State17 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let head = tokens.next().unwrap();
                    let Token::Ident(value) = head else {
                        unreachable!()
                    };
                    let head = Token::Ident(Default::default());
                    state = State::State19;
                    stack.push(state, TokenType::Term(head), StackValue::Term_Ident(value));
                }
                None => {
                    let value = { Vec::new() };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Rules(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Rules),
                        StackValue::NonTerm_Rules(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![Some(Token::Ident(Default::default())), None],
                        received: tokens.next(),
                        state_id: 17,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State18 => match tokens.peek() {
                None => {
                    let v1 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Rules),
                                StackValue::NonTerm_Rules(v),
                            ) => v,
                            _ => return Err(Error::msg("expected token Rules to be on the stack")),
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (_, TokenType::NonTerm(NonTerm::Rule), StackValue::NonTerm_Rule(v)) => {
                                v
                            }
                            _ => return Err(Error::msg("expected token Rule to be on the stack")),
                        }
                    };
                    let value = {
                        {
                            let mut v = v1;
                            v.push(v0);
                            v
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Rules(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Rules),
                        StackValue::NonTerm_Rules(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![None],
                        received: tokens.next(),
                        state_id: 18,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State19 => match tokens.peek() {
                Some(Token::Colon) => {
                    let head = tokens.next().unwrap();
                    state = State::State6;
                    stack.push(state, TokenType::Term(head), StackValue::None);
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![Some(Token::Colon)],
                        received: tokens.next(),
                        state_id: 19,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State20 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let head = tokens.next().unwrap();
                    let Token::Ident(value) = head else {
                        unreachable!()
                    };
                    let head = Token::Ident(Default::default());
                    state = State::State2;
                    stack.push(state, TokenType::Term(head), StackValue::Term_Ident(value));
                }
                None => {
                    let value = { Vec::new() };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Rules(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Rules),
                        StackValue::NonTerm_Rules(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![None, Some(Token::Ident(Default::default()))],
                        received: tokens.next(),
                        state_id: 20,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State21 => match tokens.peek() {
                Some(Token::Ident(_)) => {
                    let v1 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Config),
                                StackValue::NonTerm_Config(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Config to be on the stack"))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Configs),
                                StackValue::NonTerm_Configs(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Configs to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        {
                            let mut v0 = v0;
                            v0.push(v1);
                            v0
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Configs(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Configs),
                        StackValue::NonTerm_Configs(value),
                    );
                }
                None => {
                    let v1 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Config),
                                StackValue::NonTerm_Config(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Config to be on the stack"))
                            }
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Configs),
                                StackValue::NonTerm_Configs(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Configs to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        {
                            let mut v0 = v0;
                            v0.push(v1);
                            v0
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Configs(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Configs),
                        StackValue::NonTerm_Configs(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![Some(Token::Ident(Default::default())), None],
                        received: tokens.next(),
                        state_id: 21,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State22 => match tokens.peek() {
                None => {
                    let v1 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Rules),
                                StackValue::NonTerm_Rules(v),
                            ) => v,
                            _ => return Err(Error::msg("expected token Rules to be on the stack")),
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Configs),
                                StackValue::NonTerm_Configs(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Configs to be on the stack"))
                            }
                        }
                    };
                    let value = {
                        Spec {
                            rules: v1,
                            configs: v0,
                        }
                    };
                    let &(before, _, _) = stack.peek()?;
                    let goto = goto_Grammar(before)?;
                    state = goto;
                    stack.push(
                        goto,
                        TokenType::NonTerm(NonTerm::Grammar),
                        StackValue::NonTerm_Grammar(value),
                    );
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![None],
                        received: tokens.next(),
                        state_id: 22,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State23 => match tokens.peek() {
                None => {
                    state = State::State24;
                    stack.push(state, TokenType::TermEof, StackValue::None);
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![None],
                        received: tokens.next(),
                        state_id: 23,
                        remaining_input: tokens.collect(),
                    })
                }
            },

            State::State24 => match tokens.peek() {
                None => {
                    let v1 = {
                        match stack.pop()? {
                            (_, TokenType::TermEof, StackValue::None) => (),
                            _ => return Err(Error::msg("expected token  to be on the stack")),
                        }
                    };
                    let v0 = {
                        match stack.pop()? {
                            (
                                _,
                                TokenType::NonTerm(NonTerm::Grammar),
                                StackValue::NonTerm_Grammar(v),
                            ) => v,
                            _ => {
                                return Err(Error::msg("expected token Grammar to be on the stack"))
                            }
                        }
                    };
                    return Ok(v0);
                }
                _ => {
                    return Err(Error::UnexpectedToken {
                        expected: vec![None],
                        received: tokens.next(),
                        state_id: 24,
                        remaining_input: tokens.collect(),
                    })
                }
            },
        }
    }
}
