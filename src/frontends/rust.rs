use std::collections::HashMap;

use anyhow::Context;
use itertools::Itertools;

use crate::generator::Uid;

use super::{Format, Visitor};

pub struct Rust {
    prelude: String,
    non_terminal_types: HashMap<String, String>,
    terminal_types: HashMap<String, String>,
    token_type: String,
    entry_rule: String,
    use_default_for_token: bool,
}
impl Format for Rust {
    fn format(&self, path: &str) -> anyhow::Result<()> {
        let mut handle = std::process::Command::new("rustfmt")
            .arg(path)
            .spawn()
            .context("could not spawn rustfmt")?;
        handle.wait().context("could not wait for rustfmt")?;
        Ok(())
    }
}

impl Rust {
    pub fn new(
        prelude: String,
        mut non_terminal_types: HashMap<String, String>,
        terminal_types: HashMap<String, String>,
        entry_rule: String,
        token_type: String,
    ) -> Self {
        non_terminal_types.insert(
            "S0".to_owned(),
            non_terminal_types
                .get(&entry_rule)
                .expect("entry rule is missing in types")
                .to_owned(),
        );
        Rust {
            prelude,
            non_terminal_types,
            terminal_types,
            token_type,
            entry_rule,
            use_default_for_token: false,
        }
    }

    pub fn use_default_for_token(mut self) -> Self {
        self.use_default_for_token = true;
        self
    }
}

impl Visitor for Rust {
    fn before_enter(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        all_states: &[crate::generator::Uid],
    ) -> std::fmt::Result {
        let pool = ctx.grammar.pool();
        let token_type = &self.token_type;
        writeln!(
            f,
            "// this is file generated by {} {}",
            env!("CARGO_PKG_NAME"),
            env!("CARGO_PKG_VERSION")
        )?;
        writeln!(f, "#![allow(non_camel_case_types)]")?;
        writeln!(f, "#![allow(non_snake_case)]")?;
        writeln!(f, "#![allow(clippy::let_unit_value)]")?;
        writeln!(f, "#![allow(unused_variables)]")?;
        writeln!(f)?;
        writeln!(f, "{}", self.prelude)?;
        writeln!(f)?;
        writeln!(f, "#[derive(Debug, Clone)]")?;
        writeln!(
            f,
            r#"pub enum Error{{ Msg(String),
                UnexpectedToken{{
                    expected: Vec<Option<{}>>,
                    received: Option<{}>,
                    state_id: usize,
                    remaining_input: Vec<{token_type}> 
                }}
            }}


            impl std::fmt::Display for Error {{
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
                    write!(f, "{{self:?}}")
                }}
            }}

            impl std::error::Error for Error {{}}
            "#,
            if self.use_default_for_token {
                token_type
            } else {
                "&'static str"
            },
            self.token_type,
        )?;
        writeln!(
            f,
            r#"
            impl Error {{
                fn msg(m: &str) -> Self {{
                    Error::Msg(m.to_owned())
                }}
            }}
        "#
        )?;
        writeln!(f, "pub type Result<T> = std::result::Result<T, Error>;\n")?;
        writeln!(f, "#[derive(Debug, Clone, Copy)] enum State{{")?;
        for state in all_states {
            writeln!(f, "State{state},")?;
        }
        writeln!(f, "}}\n")?;

        // writeln!(
        //     f,
        //     r#"impl State {{
        //         fn id(self) -> usize {{
        //             match self {{"#
        // )?;
        //
        // for state in all_states {
        //     writeln!(f, "State{state} => {state},")?;
        // }
        //
        // writeln!(f, "}} }} }}\n")?;

        writeln!(f, "#[allow(dead_code)] enum StackValue {{")?;
        for nonterm in ctx
            .grammar
            .entries()
            .iter()
            .map(|x| x.rule_name())
            .sorted()
            .dedup()
        {
            let name = pool.get(nonterm);
            writeln!(
                f,
                "NonTerm_{}({}),",
                name,
                self.non_terminal_types
                    .get(name)
                    .expect("undefined non terminal type")
            )?;
        }

        for term in ctx
            .grammar
            .entries()
            .iter()
            .flat_map(|x| x.tokens())
            .filter_map(|x| x.term())
            .sorted()
            .dedup()
        {
            let name = pool.get(term);
            if let Some(typ) = self.terminal_types.get(name) {
                writeln!(f, "Term_{}({typ}),", name)?;
            }
        }

        writeln!(f, "None\n")?;
        writeln!(f, "}}\n")?;

        writeln!(f, "enum NonTerm {{")?;
        for non_term in ctx
            .grammar
            .entries()
            .iter()
            .map(|x| x.rule_name())
            .sorted()
            .dedup()
        {
            let name = pool.get(non_term);

            writeln!(f, "{name},")?;
        }
        writeln!(f, "}}\n")?;
        writeln!(
            f,
            "enum TokenType {{ Term ({token_type}), NonTerm(NonTerm), TermEof }}\n"
        )?;

        writeln!(f, "struct Stack(Vec<(State, TokenType, StackValue)>);\n")?;
        writeln!(
            f,
            r#"
        impl Stack {{
            fn pop(&mut self) -> Result<(State, TokenType, StackValue)> {{
                match self.0.pop() {{
                    None => Err(Error::msg("stack was empty. this is probably a bug")),
                    Some(x) => Ok(x),
                }}
            }}

            fn push(&mut self, state: State, typ: TokenType, val: StackValue) {{
                self.0.push((state, typ, val));
            }}

            fn peek(&self) -> Result<&(State, TokenType, StackValue)> {{
                match self.0.last() {{
                    None => Err(Error::msg("stack was empty. this is probably a bug")),
                    Some(x) => Ok(x),
                }}
            }}
        }}
        "#
        )?;

        writeln!(
            f,
            "pub fn parse<I>(tokens: I) -> Result<{}> where I: Iterator<Item = {token_type}>, {{",
            self.non_terminal_types
                .get(&self.entry_rule)
                .expect("non_terminal_types does not contain entry rule"),
        )?;
        writeln!(f, "let mut tokens = tokens.peekable();")?;
        writeln!(f, "let mut state = State::State1;")?;
        writeln!(f, "let mut stack = Stack(Vec::new());")?;
        writeln!(
            f,
            "stack.push(State::State1, TokenType::NonTerm(NonTerm::{}), StackValue::None);",
            ctx.grammar.pool().get(
                ctx.grammar
                    .entries()
                    .last()
                    .expect("grammar was empty, this should never happen")
                    .rule_name()
            )
        )?;
        Ok(())
    }

    fn begin_parse_loop(&self, _ctx: &super::Ctx, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        writeln!(
            f,
            r#"
            loop{{
            match state {{"#
        )?;
        Ok(())
    }

    fn end_parse_loop(&self, _ctx: &super::Ctx, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        writeln!(f, "}} }}")?;
        Ok(())
    }

    fn after_leave(
        &self,
        _ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        _all_states: &[crate::generator::Uid],
    ) -> std::fmt::Result {
        writeln!(f, "}}")?;
        Ok(())
    }

    fn enter_state(
        &self,
        _ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
    ) -> std::fmt::Result {
        writeln!(f, "State::State{state} =>")?;
        writeln!(f, "match tokens.peek() {{")?;
        Ok(())
    }

    fn leave_state(
        &self,
        _ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
    ) -> std::fmt::Result {
        writeln!(f, "}}\n")?;
        Ok(())
    }

    fn enter_match(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
        token: crate::grammar::Token,
    ) -> std::fmt::Result {
        let token_type = &self.token_type;
        let pool = ctx.grammar.pool();
        match token {
            crate::grammar::Token::Term(id) => {
                let name = pool.get(id);
                writeln!(
                    f,
                    "Some({token_type}::{}{}) => {{",
                    name,
                    if self.terminal_types.contains_key(name) {
                        "(_)"
                    } else {
                        ""
                    }
                )?;
            }
            crate::grammar::Token::Eof => {
                // it is fine to not assign head here, as it is impossible to shift Eof
                writeln!(f, "None => {{")?;
            }
            _ => unreachable!(),
        }
        Ok(())
    }

    fn leave_match(
        &self,
        _ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
        _token: crate::grammar::Token,
    ) -> std::fmt::Result {
        writeln!(f, "}}")?;
        Ok(())
    }

    fn visit_shift(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
        token: crate::grammar::Token,
        next_state: crate::generator::Uid,
    ) -> std::fmt::Result {
        if let crate::grammar::Token::Term(id) = token {
            let token_type = &self.token_type;
            let name = ctx.grammar.pool().get(id);
            writeln!(f, "let head = tokens.next().unwrap();")?;
            if self.terminal_types.contains_key(name) {
                writeln!(
                    f,
                    "let {token_type}::{name}(value) = head else {{ unreachable!() }}; "
                )?;
                assert!(
                    self.use_default_for_token,
                    "not sure yet how to handle non defaultable tokens"
                );
                writeln!(f, "let head = {token_type}::{name}(Default::default());")?;
            }
        }
        writeln!(f, "state = State::State{next_state};")?;
        match token {
            crate::grammar::Token::Term(id) => {
                let name = ctx.grammar.pool().get(id);
                write!(f, "stack.push(state, TokenType::Term(head), ")?;
                if self.terminal_types.contains_key(name) {
                    write!(f, "StackValue::Term_{name}(value)")?;
                } else {
                    write!(f, "StackValue::None")?;
                }

                writeln!(f, ");")?;
            }
            crate::grammar::Token::Eof => {
                writeln!(
                    f,
                    "stack.push(state, TokenType::TermEof, StackValue::None);"
                )?;
            }
            _ => unreachable!(),
        }
        Ok(())
    }

    fn visit_reduce(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
        _token: crate::grammar::Token,
        rule: crate::string_pool::Id,
        expansion: &[crate::grammar::Token],
    ) -> std::fmt::Result {
        let rule_name = ctx.grammar.pool().get(rule);
        for (i, token) in expansion.iter().enumerate().rev() {
            writeln!(f, "let v{i} = {{")?;
            writeln!(f, "match stack.pop()? {{")?;
            write!(f, "(_, ")?;
            let value = match token {
                crate::grammar::Token::Term(id) => {
                    let name = ctx.grammar.pool().get(*id);
                    let has_type = self.terminal_types.contains_key(name);
                    write!(
                        f,
                        "TokenType::Term({}::{name}{}),",
                        self.token_type,
                        if has_type { "(_)" } else { "" }
                    )?;

                    if has_type {
                        write!(f, "StackValue::Term_{name}(v)")?;
                        "v"
                    } else {
                        write!(f, "StackValue::None")?;
                        "()"
                    }
                }
                crate::grammar::Token::Eof => {
                    write!(f, "TokenType::TermEof, StackValue::None")?;

                    "()"
                }
                crate::grammar::Token::NonTerm(id) => {
                    let name = ctx.grammar.pool().get(*id);
                    write!(
                        f,
                        "TokenType::NonTerm(NonTerm::{name}), StackValue::NonTerm_{name}(v)"
                    )?;
                    "v"
                }
                _ => unreachable!(),
            };
            writeln!(f, ") => {value},")?;
            writeln!(
                f,
                r#"_ => return Err(Error::msg("expected token {} to be on the stack"))"#,
                token.display(ctx.grammar.pool())
            )?;
            writeln!(f, "}}")?;
            writeln!(f, "}};")?;
        }

        let code = ctx
            .grammar
            .entries()
            .iter()
            .find(|x| x.rule_name() == rule && x.tokens() == expansion)
            .unwrap()
            .code();
        if rule_name == "S0" {
            writeln!(f, "return Ok(v0);")?;
            return Ok(());
        }
        writeln!(f, "let value = {{ {code} }};",)?;

        writeln!(f, "let &(before, _, _) = stack.peek()?;")?;
        writeln!(f, "let goto = goto_{rule_name}(before)?;")?;
        writeln!(f, "state = goto;")?;
        writeln!(
            f,
            "stack.push(goto, TokenType::NonTerm(NonTerm::{rule_name}), StackValue::NonTerm_{rule_name}(value) );"
        )?;

        Ok(())
    }

    fn matching_error(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
        expected: std::collections::HashSet<crate::grammar::Token>,
    ) -> std::fmt::Result {
        writeln!(
            f,
            r#"_ => return Err(Error::UnexpectedToken {{
                expected: vec!["#
        )?;
        for tok in expected.iter() {
            match tok {
                crate::grammar::Token::Term(id) => {
                    let tok_name = ctx.grammar.pool().get(*id);
                    if self.use_default_for_token {
                        write!(f, "Some({}::{tok_name}", self.token_type)?;
                        if self.terminal_types.contains_key(tok_name) {
                            write!(f, "(Default::default())")?;
                        }
                        write!(f, "),")?;
                    } else {
                        write!(f, r#" Some("{tok_name}"), "#)?;
                    }
                }
                crate::grammar::Token::Eof => write!(f, "None,")?,
                _ => unreachable!(),
            }
        }
        writeln!(
            f,
            "], received: tokens.next(), state_id: {state}, remaining_input: tokens.collect() "
        )?;
        writeln!(f, "}} )")?;
        Ok(())
    }

    fn visit_goto(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        symbol: crate::string_pool::Id,
        gotos: &mut dyn Iterator<Item = (Uid, Uid)>,
    ) -> std::fmt::Result {
        let pool = ctx.grammar.pool();
        let name = pool.get(symbol);
        writeln!(f, "fn goto_{name}(state: State) -> Result<State> {{")?;
        writeln!(f, "match state {{")?;
        for (from, to) in gotos.into_iter() {
            writeln!(f, "State::State{from} => Ok(State::State{to}),")?;
        }
        writeln!(
            f,
            r#"_ => Err(Error::msg("failed to match in {name}. this is probably a bug")),"#
        )?;
        writeln!(f, "}} }}")?;
        Ok(())
    }
}
