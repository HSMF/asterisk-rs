use std::cell::Cell;

use itertools::Itertools;
use textwrap::dedent;

use super::{Format, Visitor};

#[derive(Debug)]
pub struct Python {
    prelude: String,
    gen_token_fn: Option<String>,
    indent_level: Cell<usize>,
    get_data: String,
    get_kind: String,
    token_kind: String,
    first_state: Cell<bool>,
}

/* struct IndentFmt<'a, 'b> {
    inner: &'a mut Formatter<'b>,
    buf: String,
    indent_level: usize,
}

impl<'a, 'b> IndentFmt<'a, 'b> {
    fn new(inner: &'a mut Formatter<'b>, indent_level: usize) -> Self {
        Self {
            inner,
            buf: String::new(),
            indent_level,
        }
    }
}

impl<'a, 'b> Write for IndentFmt<'a, 'b> {
    fn write_str(&mut self, s: &str) -> std::fmt::Result {
        todo!()
    }
} */

impl Format for Python {
    fn format(&self, _path: &str) -> anyhow::Result<()> {
        // formatting is weird, so nope
        Ok(())
    }
}

impl Python {
    pub fn new(
        prelude: String,
        _entry_rule: String,
        gen_token_fn: Option<String>,
        get_data: String,
        get_kind: String,
        token_kind: String,
    ) -> Self {
        assert!(
            gen_token_fn.is_none(),
            "generating tokens is not yet handled"
        );
        Self {
            prelude,
            // entry_rule,
            gen_token_fn,
            get_data,
            get_kind,
            token_kind,
            indent_level: Cell::new(0),
            first_state: Cell::new(true),
        }
    }

    fn indent(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        for _ in 0..self.indent_level.get() {
            write!(f, "    ")?;
        }
        Ok(())
    }

    fn enter(&self) {
        self.indent_level.set(self.indent_level.get() + 1);
    }
    fn leave(&self) {
        self.indent_level.set(self.indent_level.get() - 1);
    }
}

macro_rules! indent {
    ($f:expr, $self:expr ) => (
        let _: &Python = $self;
        write!($f, "")?;
    );
    ($f:expr, $self:expr , $fmt:literal) => (
        $self.indent($f)?;
        write!($f, $fmt)?;
    );
    ($f:expr, $self:expr, $fmt:literal, $($args:expr),*) => (
        $self.indent($f)?;
        write!($f, $fmt, $($args),*)?;
    )
}

macro_rules! indentln {
    ($f:expr, $self:expr ) => (
        let _: &Python = $self;
        writeln!($f, "")?;
    );
    ($f:expr, $self:expr , $fmt:literal) => (
        $self.indent($f)?;
        writeln!($f, $fmt)?;
    );
    ($f:expr, $self:expr, $fmt:literal, $($args:expr),*) => (
        $self.indent($f)?;
        writeln!($f, $fmt, $($args),*)?;
    )
}

impl Visitor for Python {
    fn before_enter(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        all_states: &[crate::generator::Uid],
    ) -> std::fmt::Result {
        let pool = ctx.grammar.pool();
        indentln!(
            f,
            self,
            "# this is file generated by {} {}",
            env!("CARGO_PKG_NAME"),
            env!("CARGO_PKG_VERSION")
        );

        indentln!(f, self);
        indentln!(f, self, "from enum import Enum");
        indentln!(f, self);
        indentln!(f, self, "{}", self.prelude);
        indentln!(f, self);
        indentln!(f, self, "def error_msg(s):");
        self.enter();
        indentln!(f, self, "raise Exception(s)");
        self.leave();
        indentln!(f, self);
        writeln!(
            f,
            "{}",
            dedent(
                r#"
        class Peekable:
            def __init__(self, it):
                self.it = it
                self._peek = (False, None)

            def peek(self):
                if self._peek[0]:
                    return (False, self._peek[1])
                try:
                    val = next(self.it)
                    self._peek = (True, val)
                    return (False, val)
                except StopIteration:
                    return (True, None)

            def __next__(self):
                if self._peek[0]:
                    ret = self._peek[1]
                    self._peek = (False, None)
                    return ret
                self._peek = (False, None)
                val = next(self.it) 
                return val
        "#
            )
        )?;

        writeln!(
            f,
            "{}",
            dedent(
                r#"
            def _asterisk_assert_eq(a, b, msg):
                if a != b:
                    error_msg(f"{a} != {b} {msg}")
        "#
            )
        )?;

        indent!(f, self, "State = Enum('State', [");
        self.enter();
        if !all_states.is_empty() {
            indentln!(f, self);
        }
        for state in all_states {
            indentln!(f, self, "'STATE{state}',");
        }
        self.leave();
        indentln!(f, self, "])\n");

        indentln!(f, self, "NonTerm = Enum('NonTerm', [");
        self.enter();
        for non_term in ctx
            .grammar
            .entries()
            .iter()
            .map(|x| x.rule_name())
            .sorted()
            .dedup()
        {
            let name = pool.get(non_term);

            indentln!(f, self, "'_{name}',");
        }
        self.leave();
        indentln!(f, self, "])");

        indentln!(
            f,
            self,
            "def parse({}):",
            if self.gen_token_fn.is_some() {
                ""
            } else {
                "tokens"
            }
        );
        self.enter();

        indentln!(f, self, "stack = []");
        indentln!(f, self, "tokens = Peekable(iter(tokens))");
        indentln!(f, self, "state = State.STATE1");
        indentln!(f, self, "stack.append((State.STATE1, None, None))");

        Ok(())
    }

    fn after_leave(
        &self,
        _ctx: &super::Ctx,
        _f: &mut std::fmt::Formatter,
        _all_states: &[crate::generator::Uid],
    ) -> std::fmt::Result {
        self.leave();
        self.first_state.set(true);
        Ok(())
    }

    fn begin_parse_loop(&self, _ctx: &super::Ctx, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        indentln!(f, self, "while True:");
        self.enter();
        Ok(())
    }

    fn end_parse_loop(&self, _ctx: &super::Ctx, _f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.leave();
        Ok(())
    }

    fn enter_state(
        &self,
        _ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
    ) -> std::fmt::Result {
        let if_kw = if self.first_state.get() { "if" } else { "elif" };
        self.first_state.set(false);
        indentln!(f, self, "{if_kw} state == State.STATE{state}:");
        self.enter();
        indentln!(f, self, "is_eof, token = tokens.peek()");
        indentln!(f, self, "kind = None");
        // indentln!(f, self, "__import__('IPython').embed()");
        indentln!(f, self, "if not is_eof:");
        self.enter();
        indentln!(f, self, "kind = {}", self.get_kind);
        self.leave();

        indentln!(f, self, "if False:");
        self.enter();
        indentln!(f, self, "pass");
        self.leave();
        Ok(())
    }

    fn leave_state(
        &self,
        _ctx: &super::Ctx,
        _f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
    ) -> std::fmt::Result {
        self.leave();
        Ok(())
    }

    fn enter_match(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
        token: crate::grammar::Token,
    ) -> std::fmt::Result {
        let pool = ctx.grammar.pool();
        match token {
            crate::grammar::Token::Term(term) => {
                let term = pool.get(term);
                indentln!(f, self, "elif kind == {}.{term}:", self.token_kind);
            }
            crate::grammar::Token::NonTerm(_) => todo!(),
            crate::grammar::Token::Empty => todo!(),
            crate::grammar::Token::Eof => {
                indentln!(f, self, "elif is_eof:");
            }
        }
        self.enter();
        Ok(())
    }

    fn leave_match(
        &self,
        _ctx: &super::Ctx,
        _f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
        _token: crate::grammar::Token,
    ) -> std::fmt::Result {
        self.leave();
        Ok(())
    }

    fn visit_shift(
        &self,
        _ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
        token: crate::grammar::Token,
        next_state: crate::generator::Uid,
    ) -> std::fmt::Result {
        if let crate::grammar::Token::Term(_id) = token {
            indentln!(f, self, "next(tokens)");
            indentln!(f, self, "data = {}", self.get_data);
        } else {
            indentln!(f, self, "data = None");
            indentln!(f, self, "kind = None");
        }
        indentln!(f, self, "state = State.STATE{next_state}");
        indentln!(f, self, "stack.append((state, kind, data))");
        Ok(())
    }

    fn visit_reduce(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        _state: crate::generator::Uid,
        _token: crate::grammar::Token,
        rule: crate::string_pool::Id,
        expansion: &[crate::grammar::Token],
    ) -> std::fmt::Result {
        let rule_name = ctx.grammar.pool().get(rule);
        let pool = ctx.grammar.pool();
        for (i, token) in expansion.iter().enumerate().rev() {
            indentln!(f, self, "_, expected_type, v{i} = stack.pop()");

            indent!(f, self, "_asterisk_assert_eq(expected_type, ");
            match token {
                crate::grammar::Token::Term(id) => {
                    let name = pool.get(*id);
                    write!(f, "{}.{name}, ", self.token_kind)?;
                }
                crate::grammar::Token::NonTerm(id) => {
                    let name = pool.get(*id);
                    write!(f, "NonTerm._{name}, ")?;
                }
                crate::grammar::Token::Eof => {
                    write!(f, "None, ")?;
                }
                crate::grammar::Token::Empty => unreachable!(),
            }
            writeln!(
                f,
                "'expected to find {} on the stack')",
                token.display(pool)
            )?;
        }
        if rule_name == "S0" {
            indentln!(f, self, "return v0");
            return Ok(());
        }
        let code = ctx
            .grammar
            .entries()
            .iter()
            .find(|x| x.rule_name() == rule && x.tokens() == expansion)
            .unwrap()
            .code();
        indentln!(f, self, "value = {code}");
        indentln!(f, self, "before, _, _ = stack[-1]");
        indentln!(f, self, "goto = goto_{rule_name}(before)");
        indentln!(f, self, "state = goto");
        indentln!(f, self, "stack.append((goto, NonTerm._{rule_name}, value))");
        Ok(())
    }

    fn matching_error(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
        expected: std::collections::HashSet<crate::grammar::Token>,
    ) -> std::fmt::Result {
        let pool = ctx.grammar.pool();
        indentln!(f, self, "else:");
        self.enter();
        indentln!(
            f,
            self,
            "error_msg('expected one of {} in state {state}')",
            expected.iter().map(|x| x.display(pool)).format(", ")
        );
        self.leave();
        Ok(())
    }

    fn visit_goto(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        symbol: crate::string_pool::Id,
        gotos: &mut dyn Iterator<Item = (crate::generator::Uid, crate::generator::Uid)>,
    ) -> std::fmt::Result {
        let pool = ctx.grammar.pool();
        let name = pool.get(symbol);
        indentln!(f, self, "def goto_{name}(state):");
        self.enter();
        for (i, (from, to)) in gotos.into_iter().enumerate() {
            let kw = if i == 0 { "if" } else { "elif" };
            indentln!(
                f,
                self,
                "{kw} state == State.STATE{from}: return State.STATE{to}"
            );
        }
        indentln!(
            f,
            self,
            "else: error_msg('failed to match in {name}. this is probably a bug.')"
        );

        self.leave();
        Ok(())
    }
}
