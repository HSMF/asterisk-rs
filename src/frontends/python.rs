use super::{Format, Visitor};

#[derive(Debug)]
pub struct Python {
    prelude: String,
    entry_rule: String,
    gen_token_fn: Option<String>,
    token_type: String,
    indent_level: usize,
}

impl Format for Python {
    fn format(&self, _path: &str) -> anyhow::Result<()> {
        // formatting is weird, so nope
        Ok(())
    }
}

impl Python {
    pub fn new(
        prelude: String,
        entry_rule: String,
        token_type: String,
        gen_token_fn: Option<String>,
    ) -> Self {
        Self {
            prelude,
            entry_rule,
            gen_token_fn,
            token_type,
            indent_level: 0
        }
    }

    fn indent(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        for _ in 0..self.indent_level{
            write!(f, "    ")?;
        }
        Ok(())
    }

    fn enter(&mut self) {
        self.indent_level += 1;
    }
    fn leave(&mut self) {
        self.indent_level -= 1;
    }
}

macro_rules! indented {
    ($f:expr, $fmt:literal, $self:expr) => (
        $self.indent($f)?;
        writeln!($f, $fmt)?;
    );
    ($f:expr, $fmt:literal, $self:expr, $($args:expr),*) => (
        $self.indent($f)?;
        writeln!($f, $fmt, $($args),*)?;
    )
}

impl Visitor for Python {
    fn before_enter(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        all_states: &[crate::generator::Uid],
    ) -> std::fmt::Result {
        writeln!(
            f,
            "# this is file generated by {} {}",
            env!("CARGO_PKG_NAME"),
            env!("CARGO_PKG_VERSION")
        )?;
        writeln!(f)?;
        writeln!(f, "{}", self.prelude)?;
        writeln!(f)?;
        writeln!(
            f,
            "def parse({}):",
            if self.gen_token_fn.is_some() {
                ""
            } else {
                "tokens"
            }
        )?;

        indented!(f, "stack = []", self);

        todo!()
    }

    fn after_leave(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        all_states: &[crate::generator::Uid],
    ) -> std::fmt::Result {
        todo!()
    }

    fn begin_parse_loop(&self, ctx: &super::Ctx, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        todo!()
    }

    fn end_parse_loop(&self, ctx: &super::Ctx, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        todo!()
    }

    fn enter_state(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
    ) -> std::fmt::Result {
        todo!()
    }

    fn leave_state(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
    ) -> std::fmt::Result {
        todo!()
    }

    fn enter_match(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
        token: crate::grammar::Token,
    ) -> std::fmt::Result {
        todo!()
    }

    fn leave_match(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
        token: crate::grammar::Token,
    ) -> std::fmt::Result {
        todo!()
    }

    fn visit_shift(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
        token: crate::grammar::Token,
        next_state: crate::generator::Uid,
    ) -> std::fmt::Result {
        todo!()
    }

    fn visit_reduce(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
        token: crate::grammar::Token,
        rule: crate::string_pool::Id,
        expansion: &[crate::grammar::Token],
    ) -> std::fmt::Result {
        todo!()
    }

    fn matching_error(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        state: crate::generator::Uid,
        expected: std::collections::HashSet<crate::grammar::Token>,
    ) -> std::fmt::Result {
        todo!()
    }

    fn visit_goto(
        &self,
        ctx: &super::Ctx,
        f: &mut std::fmt::Formatter,
        symbol: crate::string_pool::Id,
        gotos: &mut dyn Iterator<Item = (crate::generator::Uid, crate::generator::Uid)>,
    ) -> std::fmt::Result {
        todo!()
    }
}
